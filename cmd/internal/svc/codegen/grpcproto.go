package codegen

import (
	"bufio"
	"fmt"
	"github.com/sirupsen/logrus"
	v3 "github.com/youminxue/v2/cmd/internal/protobuf/v3"
	"github.com/youminxue/v2/toolkit/astutils"
	v3Helper "github.com/youminxue/v2/toolkit/openapi/v3"
	"github.com/youminxue/v2/toolkit/templateutils"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

var protoTmpl = `/**
* Generated by go-doudou {{.Version}}.
* Don't edit!
*
* Version No.: {{.ProtoVer}}
*/
syntax = "proto3";

package {{.Package}};
option go_package = "{{.GoPackage}}";
{{ range $i := .Imports }}
import "{{$i}}";
{{- end }}
{{ range $e := .Enums }}
enum {{$e.Name}} {
  {{- range $f := $e.Fields }}
  {{$f.Name}} = {{$f.Number}};
  {{- end }}
}
{{- end }}

{{- range $m := .Messages }}
{{ Eval "Message" $m }}
{{- end }}

{{- define "Message"}}
{{- if .Comments }}
{{ toComment .Comments }}
{{- end }}
message {{.Name}} {
  {{- range $f := .Fields }}
  {{- if $f.Type.Inner}}
  {{ Eval "Message" $f.Type }}
  {{- end }}
  {{- if $f.Comments }}
  {{ toComment $f.Comments }}
  {{- end }}
  {{$f.Type.GetName}} {{$f.Name}} = {{$f.Number}}{{if $f.JsonName}} [json_name="{{$f.JsonName}}"]{{end}};
  {{- end }}
}
{{- end}}

service {{.Name}} {
  {{- range $r := .Rpcs }}
  {{- if $r.Comments }}
  {{ toComment $r.Comments }}
  {{- end }}
  rpc {{$r.Name}}({{$r.Request.Name}}) returns ({{$r.Response.Name}});
  {{- end}}
}
`

func toComment(comments []string) string {
	if len(comments) == 0 {
		return ""
	}
	var b strings.Builder
	for i := range comments {
		b.WriteString(fmt.Sprintf("// %s\n", comments[i]))
	}
	return strings.TrimSuffix(b.String(), "\n")
}

func GenGrpcProto(dir string, ic astutils.InterfaceCollector, p v3.ProtoGenerator) (service v3.Service, protoFile string) {
	var (
		err       error
		svcname   string
		fi        os.FileInfo
		tpl       *template.Template
		f         *os.File
		modfile   string
		modf      *os.File
		modName   string
		firstLine string
		grpcDir   string
	)
	grpcDir = filepath.Join(dir, "transport/grpc")
	if err = os.MkdirAll(grpcDir, os.ModePerm); err != nil {
		panic(err)
	}
	svcname = ic.Interfaces[0].Name
	protoFile = filepath.Join(grpcDir, strings.ToLower(svcname)+".proto")
	if fi, err = os.Stat(protoFile); err != nil && !os.IsNotExist(err) {
		panic(err)
	}
	if fi != nil {
		logrus.Warningln("file " + protoFile + " will be overwritten")
	}
	if f, err = os.Create(protoFile); err != nil {
		panic(err)
	}
	defer f.Close()
	modfile = filepath.Join(dir, "go.mod")
	if modf, err = Open(modfile); err != nil {
		panic(err)
	}
	reader := bufio.NewReader(modf)
	firstLine, _ = reader.ReadString('\n')
	modName = strings.TrimSpace(strings.TrimPrefix(firstLine, "module"))

	service = p.NewService(svcname, modName+"/transport/grpc")
	service.Comments = ic.Interfaces[0].Comments
	for _, method := range ic.Interfaces[0].Methods {
		service.Rpcs = append(service.Rpcs, p.NewRpc(method))
	}
	for k := range v3.ImportStore {
		service.Imports = append(service.Imports, k)
	}
	sort.Strings(service.Imports)
	for _, v := range v3.MessageStore {
		service.Messages = append(service.Messages, v)
	}
	sort.SliceStable(service.Messages, func(i, j int) bool {
		return service.Messages[i].Name < service.Messages[j].Name
	})
	for _, v := range v3.EnumStore {
		service.Enums = append(service.Enums, v)
	}
	sort.SliceStable(service.Enums, func(i, j int) bool {
		return service.Enums[i].Name < service.Enums[j].Name
	})
	tpl = template.New("proto.tmpl")
	funcMap := make(map[string]interface{})
	funcMap["toComment"] = toComment
	funcMap["Eval"] = templateutils.Eval(tpl)
	if tpl, err = tpl.Funcs(funcMap).Parse(protoTmpl); err != nil {
		panic(err)
	}
	if err = tpl.Execute(f, service); err != nil {
		panic(err)
	}
	return
}

func messagesOf(vofile string, p v3.ProtoGenerator) []v3.Message {
	fset := token.NewFileSet()
	root, err := parser.ParseFile(fset, vofile, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	sc := astutils.NewStructCollector(ExprStringP)
	ast.Walk(sc, root)
	structs := sc.DocFlatEmbed()
	var ret []v3.Message
	for _, item := range structs {
		ret = append(ret, p.NewMessage(item))
	}
	return ret
}

func ParseDtoGrpc(dir string, p v3.ProtoGenerator, dtoDir string) {
	var (
		err        error
		messages   []v3.Message
		allMethods map[string][]astutils.MethodMeta
		allConsts  map[string][]string
	)
	vodir := filepath.Join(dir, dtoDir)
	if _, err = os.Stat(vodir); os.IsNotExist(err) {
		return
	}
	var files []string
	err = filepath.Walk(vodir, astutils.Visit(&files))
	if err != nil {
		panic(err)
	}
	for _, file := range files {
		v3.MessageNames = append(v3.MessageNames, getSchemaNames(file)...)
	}
	allMethods = make(map[string][]astutils.MethodMeta)
	allConsts = make(map[string][]string)
	for _, file := range files {
		sc := astutils.EnumsOf(file, ExprStringP)
		for k, v := range sc.Methods {
			allMethods[k] = append(allMethods[k], v...)
		}
		for k, v := range sc.Consts {
			allConsts[k] = append(allConsts[k], v...)
		}
	}
	for k, v := range allMethods {
		if v3Helper.IsEnumType(v) {
			v3.EnumStore[k] = p.NewEnum(astutils.EnumMeta{
				Name:   k,
				Values: allConsts[k],
			})
		}
	}
	for _, file := range files {
		messages = append(messages, messagesOf(file, p)...)
	}
	for _, item := range messages {
		v3.MessageStore[item.Name] = item
	}
}
