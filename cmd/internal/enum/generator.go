package enum

import (
	"bytes"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/youminxue/odin/toolkit/astutils"
	"github.com/youminxue/odin/toolkit/stringutils"
	"github.com/youminxue/odin/version"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

var enumsTmpl = `/**
* Generated by odin {{.Version}}.
* Don't edit!
*/
package {{.Package}}

import "encoding/json"

{{- range $m := .Enums }}

func ({{$m.Receiver}} *{{$m.Name}}) StringSetter(value string) {
	switch value {
	{{- range $v := $m.Values}}
	case "{{$v}}":
		*{{$m.Receiver}} = {{$v}}
	{{- end }}
	default:
		*{{$m.Receiver}} = {{index $m.Values 0}}
	}
}

func ({{$m.Receiver}} *{{$m.Name}}) StringGetter() string {
	switch *{{$m.Receiver}} {
	{{- range $v := $m.Values}}
	case {{$v}}:
		return "{{$v}}"
	{{- end }}
	default:
		return "{{index $m.Values 0}}"
	}
}

func ({{$m.Receiver}} *{{$m.Name}}) UnmarshalJSON(bytes []byte) error {
	var _{{$m.Receiver}} string
	err := json.Unmarshal(bytes, &_{{$m.Receiver}})
	if err != nil {
		return err
	}
	{{$m.Receiver}}.StringSetter(_{{$m.Receiver}})
	return nil
}

func ({{$m.Receiver}} *{{$m.Name}}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{$m.Receiver}}.StringGetter())
}
{{- end }}
`

type Generator struct {
	_    [0]int
	File string
}

type Enum struct {
	astutils.EnumMeta
	Receiver string
}

func (receiver Generator) Generate() {
	var (
		f       *os.File
		err     error
		codeBuf bytes.Buffer
		fi      os.FileInfo
	)
	if stringutils.IsEmpty(receiver.File) {
		panic(errors.New("file flag should not be empty"))
	}
	sc := astutils.EnumsOf(receiver.File, astutils.ExprString)
	getReceiver := func(s string) string {
		return strings.ToLower(string([]rune(s)[0]))
	}
	var enums []Enum
	for k, v := range sc.Consts {
		enums = append(enums, Enum{
			EnumMeta: astutils.EnumMeta{
				Name:   k,
				Values: v,
			},
			Receiver: getReceiver(k),
		})
	}
	sort.SliceStable(enums, func(i, j int) bool {
		return enums[i].Name < enums[j].Name
	})
	dir := filepath.Dir(receiver.File)
	enumsFile := filepath.Join(dir, "enums_gen.go")
	fi, err = os.Stat(enumsFile)
	if err != nil && !os.IsNotExist(err) {
		panic(err)
	}
	if fi != nil {
		logrus.Warningln("file enums_gen.go will be overwritten")
	}
	if f, err = os.Create(enumsFile); err != nil {
		panic(err)
	}
	defer f.Close()
	tpl := template.New("enums.tmpl")
	if tpl, err = tpl.Parse(enumsTmpl); err != nil {
		panic(err)
	}
	if err = tpl.Execute(&codeBuf, struct {
		Package string
		Enums   []Enum
		Version string
	}{
		Package: sc.Package.Name,
		Enums:   enums,
		Version: version.Release,
	}); err != nil {
		panic(err)
	}
	source := strings.TrimSpace(codeBuf.String())
	astutils.FixImport([]byte(source), enumsFile)
}
